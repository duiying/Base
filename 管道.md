# 管道

如果你学过 Linux 命令，那你肯定很熟悉「|」这个竖线。  

```sh
ps -ef | grep mysql
```

上面命令行里的「|」竖线就是一个**管道**，它的功能是将前一个命令（ps -ef）的输出，作为后一个命令（grep mysql）的输入，从这功能描述，可以看出**管道传输数据是单向的**，如果想相互通信，我们需要创建两个管道才行。  

同时，我们得知上面这种管道是没有名字，所以「|」表示的管道称为**匿名管道**，用完了就销毁。  

管道还有另外一个类型是**命名管道**，也被叫做 **FIFO**，因为数据是**先进先出**的传输方式。  

不管是匿名管道还是命名管道，进程写入的数据都是**缓存在内核中**，另一个进程读取数据时候自然也是从内核中获取，同时通信数据都遵循**先进先出**原则，不支持 lseek 之类的文件定位操作。

管道这种通信方式效率低，不适合进程间频繁地交换数据。当然，它的好处就是简单，同时也我们很容易得知管道里的数据已经被另一个进程读取了（**数据不可反复读取，一旦被读走，在管道中就不复存在了**）。   

**1、用管道实现父子进程间的通信**：  

```php
<?php

echo sprintf('进程启动了，pid：%d，time：%d' . PHP_EOL, posix_getpid(), time());

$pipe = '/home/work/test.pipe';

if (!file_exists($pipe)) {
    // posix_mkfifo 用于创建一个命名管道
    if (!posix_mkfifo($pipe, 0666)) {
        exit('创建命名管道失败' . PHP_EOL);
    }
}

// 创建子进程，子进程写管道，父进程读管道
$pid = pcntl_fork();

if ($pid === 0) {
    echo sprintf('子进程启动了，pid：%d' . PHP_EOL, posix_getpid());
    $fd = fopen($pipe, 'w');
    sleep(3);
    fwrite($fd, 'hello world');
    fclose($fd);
    exit;
}

$fd = fopen($pipe, 'r');
// 由于 fread，父进程会阻塞，直到管道中有数据
echo sprintf('父进程从管道中读到了数据：%s，time：%d' . PHP_EOL, fread($fd, 20), time());
fclose($fd);

// 父进程阻塞，直到子进程退出
$pid = pcntl_wait($status);
if ($pid > 0) {
    echo sprintf('子进程退出了，pid：%d' . PHP_EOL, $pid);
}
```

执行结果如下：  

```sh
[work@bogon www]$ php test.php
进程启动了，pid：2369，time：1633686876
子进程启动了，pid：2370
父进程从管道中读到了数据：hello world，time：1633686879
子进程退出了，pid：2370
```

我们查看一下管道文件的文件类型：  

```sh
$ file /home/work/test.pipe
/home/work/test.pipe: fifo (named pipe)
```

**2、当读端关闭的时候，如果写端继续写，这个时候就无法继续写入了，还会产生 SIGPIPE 的中断信号**：  

```php
<?php

echo sprintf('进程启动了，pid：%d' . PHP_EOL, posix_getpid());

$pipe = '/home/work/test.pipe';

if (!file_exists($pipe)) {
    // posix_mkfifo 用于创建一个命名管道
    if (!posix_mkfifo($pipe, 0666)) {
        exit('创建命名管道失败' . PHP_EOL);
    }
}

// 当读端关闭的时候，如果写端继续写，这个时候就无法继续写入了，还会产生 SIGPIPE 的中断信号
pcntl_signal(SIGPIPE, function($signo) {
    echo sprintf('进程 pid：%d，我收到了一个信号：%d' . PHP_EOL, posix_getpid(), $signo);
});

pcntl_signal(SIGCHLD, function($signo) {
    $pid = pcntl_waitpid(-1, $status, WNOHANG | WUNTRACED);
    if ($pid > 0) {
        echo sprintf('我是父进程，我捕捉到子进程 pid：%d 退出了' . PHP_EOL, $pid, $signo);
    }
});

// 创建子进程，子进程读管道，父进程写管道
$pid = pcntl_fork();

if ($pid === 0) {
    echo sprintf('子进程启动了，pid：%d' . PHP_EOL, posix_getpid());
    $i = 0;
    $fd = fopen($pipe, 'r');
    // 将文件设置为非阻塞方式
    stream_set_blocking($fd, 0);
    while (1) {
        if ($i >= 5) break;
        $data = fread($fd, 11);
        if ($data) {
            echo '子进程读到了数据，data：' . $data . PHP_EOL;
            $i++;
        }
        sleep(1);
    }

    fclose($fd);
    echo '子进程退出了' . PHP_EOL;
    exit;
}

$fd = fopen($pipe, 'w');
// 将文件设置为非阻塞方式
stream_set_blocking($fd, 0);
while (1) {
    pcntl_signal_dispatch();
    $len = fwrite($fd, 'hello world');
    echo '父进程写入管道数据长度：' . $len . PHP_EOL;
    sleep(1);
}
```

执行结果如下：

```sh
[work@bogon www]$ php test.php
进程启动了，pid：3345
子进程启动了，pid：3346
父进程写入管道数据长度：11
子进程读到了数据，data：hello world
父进程写入管道数据长度：11
子进程读到了数据，data：hello world
父进程写入管道数据长度：11
子进程读到了数据，data：hello world
父进程写入管道数据长度：11
子进程读到了数据，data：hello world
父进程写入管道数据长度：11
子进程读到了数据，data：hello world
父进程写入管道数据长度：11
子进程退出了
我是父进程，我捕捉到子进程 pid：3346 退出了
父进程写入管道数据长度：
进程 pid：3345，我收到了一个信号：13
父进程写入管道数据长度：
进程 pid：3345，我收到了一个信号：13
父进程写入管道数据长度：
进程 pid：3345，我收到了一个信号：13
父进程写入管道数据长度：
进程 pid：3345，我收到了一个信号：13
父进程写入管道数据长度：
进程 pid：3345，我收到了一个信号：13
父进程写入管道数据长度：
进程 pid：3345，我收到了一个信号：13
父进程写入管道数据长度：
^C
```

**3、启动一个发送进程，用 cat 作为读端，启动两个读端**：  

```php
<?php

echo sprintf('进程启动了，pid：%d' . PHP_EOL, posix_getpid());

$pipe = '/home/work/test.pipe';

if (!file_exists($pipe)) {
    // posix_mkfifo 用于创建一个命名管道
    if (!posix_mkfifo($pipe, 0666)) {
        exit('创建命名管道失败' . PHP_EOL);
    }
}

$fd = fopen($pipe, 'w');
// 将文件设置为非阻塞方式
stream_set_blocking($fd, 0);
while (1) {
    // 接收标准输入的数据，然后写入管道
    $data = fgets(STDIN, 128);
    if ($data) {
        $len = fwrite($fd, $data, strlen($data));
        echo sprintf('写入了 %d 个字节数据' . PHP_EOL, $len);
    }
}
```

启动两个读端：  

```sh
[work@bogon ~]$ cat test.pipe
```

然后启动 `test.php`，会发现两个读端会轮流地读取数据，当一个 read 进程读走数据之后，另外一个 read 进程就无法读取数据了，当然，如果关闭两个读端，写端也无法往管道中写入数据了。  

```sh
[work@bogon www]$ php test.php
进程启动了，pid：3699
1
写入了 2 个字节数据
2
写入了 2 个字节数据
3
写入了 2 个字节数据
4
写入了 2 个字节数据
5
写入了 0 个字节数据
```

上面的进程间通信使用的是命名管道，命名管道支持非父子进程间的通信（`test.php` 进程和 `cat` 进程之间的通信）。

### 总结

- **什么是管道？**（所谓的管道，就是内核里面的一串缓存。从管道的一段写入的数据，实际上是缓存在内核中的，另一端读取，也就是从内核中读取这段数据。另外，管道传输的数据是无格式的流且大小受限。）
- **管道分为几种？它们之间的区别是什么？**（两种，匿名管道 pipe 和命名管道 fifo；匿名管道只能父子进程之间通信，命名管道支持任何两个进程之间通信。）

# 消息队列

前面说到管道的通信方式是效率低的，因此管道不适合进程间频繁地交换数据。  

对于这个问题，**消息队列**的通信模式就可以解决。比如，A 进程要给 B 进程发送消息，A 进程把数据放在对应的消息队列后就可以正常返回了，B 进程需要的时候再去读取数据就可以了。同理，B 进程要给 A 进程发送消息也是如此。  

再来，**消息队列是保存在内核中的消息链表**，在发送数据时，会分成一个一个独立的数据单元，也就是消息体（数据块），消息体是用户自定义的数据类型，消息的发送方和接收方要约定好消息体的数据类型，所以每个消息体都是固定大小的存储块，不像**管道是无格式的字节流数据**。如果进程从消息队列中读取了消息体，内核就会把这个消息体删除。  

消息队列生命周期随内核，如果没有释放消息队列或者没有关闭操作系统，消息队列会一直存在，而前面提到的匿名管道的生命周期，是随进程的创建而建立，随进程的结束而销毁。  

消息这种模型，两个进程之间的通信就像平时发邮件一样，你来一封，我回一封，可以频繁沟通了。  

但邮件的通信方式存在不足的地方有两点，一是通信不及时，二是附件也有大小限制，这同样也是消息队列通信不足的点。  

**消息队列不适合比较大数据的传输**，因为在内核中每个消息体都有一个最大长度的限制，同时所有队列所包含的全部消息体的总长度也是有上限。在 Linux 内核中，会有两个宏定义 `MSGMAX` 和 `MSGMNB`，它们以字节为单位，分别定义了一条消息的最大长度和一个队列的最大长度。  

**消息队列通信过程中，存在用户态与内核态之间的数据拷贝开销**，因为进程写入数据到内核中的消息队列时，会发生从用户态拷贝数据到内核态的过程，同理另一进程读取内核中的消息数据时，会发生从内核态拷贝数据到用户态的过程。  

我们可以用 `ipcs` 命令来打印进程间通信设施状态，包括消息队列、共享内存和信号量的信息。  

```sh
[work@bogon www]$ ipcs

--------- 消息队列 -----------
键        msqid      拥有者  权限     已用字节数 消息

------------ 共享内存段 --------------
键        shmid      拥有者  权限     字节     nattch     状态
0x00000000 2          gdm        777        16384      1          目标
0x00000000 5          gdm        777        2129920    2          目标

--------- 信号量数组 -----------
键        semid      拥有者  权限     nsems
```

我们可以看到目前消息队列为空。  

下面我们尝试往消息队列中发送一条数据：    

```php
<?php

// ftok：Convert a pathname and a project identifier to a System V IPC key（把一个路径和标识符转换成 IPC 的 key）
$key = ftok(__FILE__, 'a');
// msg_get_queue：Create or attach to a message queue（根据传入的键创建或返回一个消息队列的引用）
$queue = msg_get_queue($key);

// 往消息队列发送一条消息
msg_send($queue, 2, 'hello');

echo '消息队列发送成功' . PHP_EOL;
```

可以看到多了一个消息队列。  

```sh
[work@bogon www]$ php test.php
消息队列发送成功
[work@bogon www]$ ipcs

--------- 消息队列 -----------
键        msqid      拥有者  权限     已用字节数 消息
0x6103c315 0          root       666        12           1

------------ 共享内存段 --------------
键        shmid      拥有者  权限     字节     nattch     状态
0x00000000 2          gdm        777        16384      1          目标
0x00000000 5          gdm        777        2129920    2          目标

--------- 信号量数组 -----------
键        semid      拥有者  权限     nsems
```

**我们明明写入的是 hello，应该是 5 个字节，为什么上面显示的是已用 12 个字节？**  

先删除上面的消息队列，`ipcrm -Q 0x6103c315`，然后用 `strace` 命令追踪系统调用。  

```sh
[root@bogon www]# strace -f -s 65535 -o msg.log php test.php
消息队列发送成功
[root@bogon www]# ipcs

--------- 消息队列 -----------
键        msqid      拥有者  权限     已用字节数 消息
0x6103c315 1          root       666        12           1

------------ 共享内存段 --------------
键        shmid      拥有者  权限     字节     nattch     状态
0x00000000 2          gdm        777        16384      1          目标
0x00000000 5          gdm        777        2129920    2          目标

--------- 信号量数组 -----------
键        semid      拥有者  权限     nsems
```

<div align=center><img src="https://raw.githubusercontent.com/duiying/img/master/消息队列系统调用.png" width="1000"></div>  

从系统调用中可以看到，在调用底层 `msgsnd` 时，参数是序列化后的 `hello`，这和 `msg_send` 函数的第四个参数有关，PHP 默认是将 message 给序列化，然后再系统调用 `msgsnd`。可以将第四个参数改成 `false`，然后查看系统调用。  

```php
// 往消息队列发送一条消息
msg_send($queue, 2, 'hello', false);
```

`msgsnd` 系统调用如下：  

```sh
msgsnd(2, {2, "hello"}, 5, 0)     = 0
```

如果你的**消息队列需要删除**，可以使用 `msg_remove_queue` 来释放掉消息队列，否则消息队列将会一直存在。  

**如何从消息队列中接收数据？**  

1、当发送端使用了序列化。  

发送端：  

```php
<?php

$key = ftok(__FILE__, 'a');
$queue = msg_get_queue($key);

// 往消息队列发送一条消息
msg_send($queue, 2, 'hello', true);

echo '消息队列发送成功' . PHP_EOL;
```

接收端：  

```php
<?php

$key = ftok(__FILE__, 'a');
$queue = msg_get_queue($key);

msg_receive($queue, 0, $msgType, 1024, $msg, true, MSG_NOERROR);
echo "msgType：$msgType msg：$msg" . PHP_EOL;
```

执行结果如下：  

```sh
[root@bogon www]# ipcs

--------- 消息队列 -----------
键        msqid      拥有者  权限     已用字节数 消息
0x6103c316 4          root       666        0            0

------------ 共享内存段 --------------
键        shmid      拥有者  权限     字节     nattch     状态
0x00000000 2          gdm        777        16384      1          目标
0x00000000 5          gdm        777        2129920    2          目标

--------- 信号量数组 -----------
键        semid      拥有者  权限     nsems

[root@bogon www]# ipcrm -Q 0x6103c316
[root@bogon www]# ipcs

--------- 消息队列 -----------
键        msqid      拥有者  权限     已用字节数 消息

------------ 共享内存段 --------------
键        shmid      拥有者  权限     字节     nattch     状态
0x00000000 2          gdm        777        16384      1          目标
0x00000000 5          gdm        777        2129920    2          目标

--------- 信号量数组 -----------
键        semid      拥有者  权限     nsems

[root@bogon www]# php test.php
消息队列发送成功
[root@bogon www]# ipcs

--------- 消息队列 -----------
键        msqid      拥有者  权限     已用字节数 消息
0x6103c314 5          root       666        12           1

------------ 共享内存段 --------------
键        shmid      拥有者  权限     字节     nattch     状态
0x00000000 2          gdm        777        16384      1          目标
0x00000000 5          gdm        777        2129920    2          目标

--------- 信号量数组 -----------
键        semid      拥有者  权限     nsems

[root@bogon www]# php test2.php
msgType：2 msg：hello
[root@bogon www]# ipcs

--------- 消息队列 -----------
键        msqid      拥有者  权限     已用字节数 消息
0x6103c314 5          root       666        0            0

------------ 共享内存段 --------------
键        shmid      拥有者  权限     字节     nattch     状态
0x00000000 2          gdm        777        16384      1          目标
0x00000000 5          gdm        777        2129920    2          目标

--------- 信号量数组 -----------
键        semid      拥有者  权限     nsems
```

上面的执行结果分析：  

1. 首先系统中没有任何消息队列。
2. 执行完发送端 `php test.php` 之后，多了一个 `msqid=5` 的消息队列，由于是 PHP 序列化过后的 message，所以占用了 12 个字节。
3. 然后执行接收端 `php test2.php`，接收到了数据 `hello`。
4. 再次查看已用字节数，发现其变成了 0。  

需要注意的是，当发送端使用了序列化，如果接收端 `msg_receive` 的第 4 个参数（接收缓冲区长度）设置过小，数据会反序列化失败，并且这条消息会被丢弃。  

```php
// 接收缓冲区被设置成了 3，设置过小，导致了反序列化失败，该条消息会从消息队列中删除
msg_receive($queue, 0, $msgType, 3, $msg, true, MSG_NOERROR);
```

如果发送端没有使用序列化，接收缓冲区长度设置过小，会发生什么呢？  

```php
// 发送端：test.php
msg_send($queue, 2, 'hello', false);

// 接收端：test2.php
msg_receive($queue, 0, $msgType, 3, $msg, false, MSG_NOERROR);
```

执行结果如下：  

```sh
[root@bogon www]# php test2.php
msgType：2 msg：hel
[root@bogon www]# ipcs

--------- 消息队列 -----------
键        msqid      拥有者  权限     已用字节数 消息
0x6103c314 6          root       666        0            0

------------ 共享内存段 --------------
键        shmid      拥有者  权限     字节     nattch     状态
0x00000000 2          gdm        777        16384      1          目标
0x00000000 5          gdm        777        2129920    2          目标

--------- 信号量数组 -----------
键        semid      拥有者  权限     nsems
```

可以看到，这种情况消息会被截断，该条消息也会从消息队列中删除。  

**可以通过 `msg_stat_queue` 查看消息队列当前的状态信息**：  

```php
$key = ftok(__FILE__, 'a');
$queue = msg_get_queue($key);
print_r(msg_stat_queue($queue));
```

**下面用多进程实现：父进程往消息队列中写 3 次消息，子进程非阻塞地读取消息，写入 3 次后父进程杀死子进程并回收子进程，最后释放掉消息队列。**  

```php
<?php

$key = ftok(__FILE__, 'a');
$queue = msg_get_queue($key);

$pid = pcntl_fork();

if ($pid === 0) {
    while (1) {
        // MSG_IPC_NOWAIT：非阻塞，立即返回；（如果使用非阻塞方式，该函数调用的次数会非常高，所以占用 CPU 资源就会高）
        msg_receive($queue, 0, $msgType, 1024, $msg, true, MSG_IPC_NOWAIT, $error);
        if ($error != MSG_ENOMSG) {
            echo "msgType：$msgType msg：$msg" . PHP_EOL;
        }
    }
}

$i = 0;

while (1) {
    if ($i++ === 3) {
        posix_kill($pid, SIGKILL);
        break;
    }
    // 往消息队列发送一条消息
    msg_send($queue, 2, 'hello', true);
    sleep(1);
}

// 回收子进程
$pid = pcntl_wait($status);
if ($pid > 0) {
    echo "子进程 $pid 退出了" . PHP_EOL;
}

// 删除消息队列
msg_remove_queue($queue);
```









# 信号量

为了防止多进程竞争共享资源，而造成的数据错乱，所以需要保护机制，使得共享的资源，在任意时刻只能被一个进程访问。正好，信号量就实现了这一保护机制。  

信号量类似于一把锁，访问前获取锁（获取不到则等待），访问后释放锁。  

我们先来看一下多进程竞争共享资源，会出现什么问题？  

```php
<?php

$key = ftok(__FILE__, 'a');

$file = '/home/work/www/data.log';

$count = 0;
file_put_contents($file, $count);

// 父子进程各自读取文件内容，然后内容 +1，再写回文件，这个过程循环 1k 次
$pid = pcntl_fork();

if ($pid === 0) {
    for ($i = 0; $i < 1000; $i++) {
        $x = (int)file_get_contents($file);
        $x += 1;
        file_put_contents($file, $x);
    }

    exit();
}

for ($i = 0; $i < 1000; $i++) {
    $x = (int)file_get_contents($file);
    $x += 1;
    file_put_contents($file, $x);
}

$pid = pcntl_wait($status);
if ($pid > 0) {
    echo "子进程 pid：$pid 退出了" . PHP_EOL;
}

$count = (int)file_get_contents($file);
echo "count：$count" . PHP_EOL;
```

执行脚本两次，结果如下：  

```sh
[work@bogon www]$ php test.php
子进程 pid：6645 退出了
count：28
[work@bogon www]$ php test.php
子进程 pid：6647 退出了
count：201
```

可以看到由于多进程竞争同一文件的资源，导致数据互相覆盖了，最后的结果也是不可控的，所以我们需要一把锁来保证文件在任意时刻只能被一个进程访问。  

```php
<?php

$key = ftok(__FILE__, 'a');
$semaphore = sem_get($key);

$file = '/home/work/www/data.log';

$count = 0;
file_put_contents($file, $count);

// 父子进程各自读取文件内容，然后内容 +1，再写回文件，这个过程循环 1k 次
$pid = pcntl_fork();

if ($pid === 0) {
    for ($i = 0; $i < 1000; $i++) {
        // 获得信号量
        sem_acquire($semaphore);

        $x = (int)file_get_contents($file);
        $x += 1;
        file_put_contents($file, $x);

        // 释放信号量
        sem_release($semaphore);
    }

    exit();
}

for ($i = 0; $i < 1000; $i++) {
    // 获得信号量
    sem_acquire($semaphore);

    $x = (int)file_get_contents($file);
    $x += 1;
    file_put_contents($file, $x);

    // 释放信号量
    sem_release($semaphore);
}

$pid = pcntl_wait($status);
if ($pid > 0) {
    echo "子进程 pid：$pid 退出了" . PHP_EOL;
}

$count = (int)file_get_contents($file);
echo "count：$count" . PHP_EOL;
```

执行结果如下：  

```sh
[work@bogon www]$ php test2.php
子进程 pid：6687 退出了
count：2000
```
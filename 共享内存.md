# 共享内存

消息队列的读取和写入的过程，都会有发生**用户态与内核态之间的消息拷贝**过程。那**共享内存**的方式，就很好的解决了这一问题。  

现代操作系统，对于内存管理，采用的是虚拟内存技术，也就是每个进程都有自己独立的虚拟内存空间，不同进程的虚拟内存映射到不同的物理内存中。所以，即使进程 A 和 进程 B 的虚拟地址是一样的，其实访问的是不同的物理内存地址，对于数据的增删查改互不影响。  

**共享内存的机制，就是拿出一块虚拟地址空间来，映射到相同的物理内存中**。这样这个进程写入的东西，另外一个进程马上就能看到了，都不需要拷贝来拷贝去，传来传去，大大提高了进程间通信的速度。  

<div align=center><img src="https://raw.githubusercontent.com/duiying/img/master/共享内存.png" width="600"></div>  

**1、先来体验一下如何往共享内存中读写数据**  

```php
<?php

$key = ftok(__FILE__, 'a');

// shm_attach：创建或打开一个共享内存段
$shm_id = shm_attach($key, 1024);
// shm_put_var：在共享内存中新增或更新变量
shm_put_var($shm_id, 1, 'hello');
echo shm_get_var($shm_id, 1) . PHP_EOL;
```

我们先用 `ipcs` 观察当前进程通信共享内存段的信息：  

```sh
------------ 共享内存段 --------------
键        shmid      拥有者  权限     字节     nattch     状态
0x00000000 9          work       777        16384      1          目标
0x00000000 10         work       777        2129920    2          目标
0x00000000 15         work       600        524288     2          目标
0x00000000 16         work       777        2129920    2          目标
0x00000000 19         work       600        524288     2          目标
0x00000000 20         work       600        524288     2          目标
```

执行脚本之后的结果：  

```sh
[work@bogon www]$ php test.php
hello
[work@bogon www]$ ipcs
---省略---
------------ 共享内存段 --------------
键        shmid      拥有者  权限     字节     nattch     状态
0x00000000 9          work       777        16384      1          目标
0x00000000 10         work       777        2129920    2          目标
0x00000000 15         work       600        524288     2          目标
0x00000000 16         work       777        2129920    2          目标
0x00000000 19         work       600        524288     2          目标
0x00000000 20         work       600        524288     2          目标
0x6103bfae 21         root       666        1024       0
---省略---
```

发现多了一个共享内存段，并且从共享内存段中读取出了刚写入的 `hello` 数据。  

我们在使用完共享内存之后，可以手动删除掉它：  

```php
// 删除指定共享内存
shm_remove($shm_id);
```

**2、启动两个进程，一个进程负责写入，一个进程负责读取并删除掉共享内存**  

进程 1 负责写入：  

```php
<?php

$file = '/home/work/www/test.php';
$key = ftok($file, 'a');
$shm_id = shm_attach($key, 1024);
shm_put_var($shm_id, 1, 'world');
```

进程 2 负责读取：  

```php
<?php

$file = '/home/work/www/test.php';
$key = ftok($file, 'a');
$shm_id = shm_attach($key, 1024);
echo shm_get_var($shm_id, 1) . PHP_EOL;
shm_remove($shm_id);
```

先执行进程 1，然后执行进程 2，会发现进程 2 从共享内存中读取到了 `world` 数据并删除了共享内存段。  

**3、除了 shm 相关函数，我们还可以用 shmop 相关函数**  

还是实现一个进程写入，一个进程读取的功能。  

进程 1：  

```php
<?php

$file = '/home/work/www/test.php';
$key = ftok($file, 'a');
$shm_id = shmop_open($key, 'c', 0666, 128);
shmop_write($shm_id, 'hello', 0);
```

进程 2：

```php
<?php

$file = '/home/work/www/test.php';
$key = ftok($file, 'a');
$shm_id = shmop_open($key, 'c', 0666, 128);
echo shmop_read($shm_id, 0, 5) . PHP_EOL;
// 关闭共享内存段，它的原理是把共享内存段与进程的地址空间映射关系给断开，并不会删除共享内存
shmop_close($shm_id);
// 如果想删除共享内存段，需要使用 shmop_delete
shmop_delete($shm_id);
```
